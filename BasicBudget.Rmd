---
title: "Basic Budget"
author: "Mike Dietze"
date: "December 9, 2014"
output: html_document
---

## TASKS

1. Load up data
2. Estimate any uncertainties required as inputs, but which were not provided in the data
3. Format data for JAGS
4. Specify / Estimate Priors
5. Specify / Estimate Initial Conditions for MCMC
6. Basic Code
7. Post-Processing & Convergence Checking
8. Visualization

## 0. Settings, etc

```{r}
setwd("~/Dropbox/HF C Synthesis")
library(rjags)

ciEnvelope <- function(x,ylo,yhi,...){
  polygon(cbind(c(x, rev(x), x[1]), c(ylo, rev(yhi),
                                      ylo[1])), border = NA,...) 
}
```


## 1. Load up data

```{r}
tree = read.csv("Data/live trees/hf-c-trees-live.csv",header=TRUE)
tree = tree[,-grep('^X',colnames(tree))]  ## drop columns with names starting with X
tree = tree[-which(is.na(tree$dbh)),] ## drop rows with missing DBH
tree = tree[-which(tree$obs.exp == "exp"),] ## drop trees from experimental manipulations

## Testing subset
tree = tree[which(tree$site %in% c("ems","hemlock","red pine plantation","mixed hardwood","pisgah")),]
```


## 2. Estimate any uncertainties required as inputs, but which were not provided in the data

### 2a. Load Allometric posteriors
```{r}
b0 = -2.48
b1 = 2.48
B = c(b0,b1)
SIGMA = solve(diag(0.0001,2))
tau.allom = 100000
```


## 3. Format data for JAGS

```{r}

year = tree$year
years = min(year):max(year)
nyears = length(years)
year.index = year+1-years[1]

site = as.factor(as.character(tree$site))
sites = unique(site)
nsites = length(sites)
site.index = as.integer(site)

plot = as.factor(paste0(as.character(site),"+",as.character(tree$plot)))
plots = unique(plot)
nplots = length(plots)
plot.index = as.integer(plot)

s2p = table(site,plot)

area = tree$size
plot.area = tapply(area,plot,mean,na.rm=TRUE)
plot.yr.cnt = table(plot,year)
stem.count = apply(plot.yr.cnt,2,sum,na.rm=TRUE)
plot.yr.area = plot.yr.cnt
for(y in 1:ncol(plot.yr.area)){
  sel = which(plot.yr.area[,y]>0)
  plot.yr.area[sel,y] = plot.area[sel]
}
census.area = apply(plot.yr.area,2,sum,na.rm=TRUE)
census.year = as.numeric(names(census.area))-years[1]+1

## need to break out census.area & census.time by SITE
site.yr.cnt = site.yr.area = matrix(NA,nrow(s2p),ncol(plot.yr.area))
mch = match(colnames(s2p),rownames(plot.yr.area))
s2pv = apply(s2p,2,function(s){which(as.logical(s))})
for(y in 1:ncol(plot.yr.area)){
  site.yr.area[,y] = tapply(plot.yr.area[,y],s2pv,sum)
  site.yr.cnt[,y]  = tapply(plot.yr.cnt[,y],s2pv,sum)
}
#site.yr.area[is.na(site.yr.cnt)] <- NA
#site.yr.cnt[is.na(site.yr.cnt)] <- NA
site.yr.time = which(site.yr.cnt > 0,arr.ind = TRUE)

## empirical estimate of stem density
rho = site.yr.cnt/site.yr.area;rho[is.nan(rho)] <- NA
plot(rho[1,],ylim=range(rho,na.rm=TRUE),type='l')
for(s in 2:nsites){
  lines(rho[s,])
}

## empirical estimate of mean tree biomass
tree.mass <- exp(b0+b1*log(tree$dbh)+0.5/tau.allom)  ## empircal mean estimate needs var/2 correction
site.mass <- matrix(NA,nsites,nyears)
for(y in 1:nyears){
  sel.y = which(tree$year == years[y])
  if(length(sel)>0){
    site.mass[,y] = tapply(tree.mass[sel.y],site[sel.y],mean,na.rm=TRUE)
  }
}
mass.yr = which(!is.na(site.mass),arr.ind = TRUE)


#data = list(dbh=tree$dbh,n=nrow(tree),ny=nyears,yi=year.index,stem.count=stem.count,census.area=census.area,census.time=census.time,B=B,SIGMA=SIGMA,tau.allom=tau.allom)

data = list(dbh=tree$dbh,n=nrow(tree),ny=nyears,yi=year.index,stem.count=site.yr.cnt,census.area=site.yr.area,census.time=site.yr.time,B=B,SIGMA=SIGMA,tau.allom=tau.allom,ns=nsites,nobs=nrow(site.yr.time),census.year=census.year,si=site.index)

```


## 4. Specify / Estimate Priors


## 5. Specify / Estimate Initial Conditions for MCMC
```{r}
x = tree$dbh
mu.ic = mean(x,na.rm=TRUE)
prec.ic = 1/var(x,na.rm=TRUE)
alpha.ic = mu.ic - tapply(x,year.index,mean,na.rm=TRUE)
tau_year.ic = 1/var(alpha.ic,na.rm=TRUE)
alpha.ic[as.numeric(names(alpha.ic))] <- alpha.ic
alpha.ic[is.na(alpha.ic)] <- rnorm(sum(is.na(alpha.ic)),0,sqrt(1/tau_year.ic))

rhop.ic = apply(rho,1,mean,na.rm=TRUE)
tau_h.ic = 1/var(rhop.ic)
rho.ic = mean(rhop.ic)
tau_proc.rhop.ic = 1/mean(apply(rho,1,function(x){var(diff(x),na.rm=TRUE)}),na.rm=TRUE)

mup0.ic = apply(site.mass,1,mean,na.rm=TRUE)
tau_proc.mup.ic = 1/mean(apply(site.mass,1,function(x){var(diff(x),na.rm=TRUE)}),na.rm=TRUE)

init =  list(mu=mu.ic+alpha.ic,mup0 = mup0.ic,tau_proc.mup=tau_proc.mup.ic,tau_obs=prec.ic,tau_proc.mu=tau_year.ic,rhop0=rhop.ic,rho0=rho.ic,tau_proc.rhop=tau_proc.rhop.ic,tau_h.rho=tau_h.ic)
```

## 6. Basic Code

```{r}
BasicBudget = "
data{
  b ~ dmnorm(B,SIGMA)
  for(i in 1:n){
    mu.allom[i] <- b[1] + b[2]*log(dbh[i]) ## expected allometric biomass, log scale
    Emass[i] ~ dlnorm(mu.allom[i],tau.allom) 
  }
}
model{

  ## Stem Biomass #################
  mu0 ~ dlnorm(3,0.001)
  for(i in 1:ns){
    mup0[i] ~dlnorm(3,0.001) 
  }
  tau_proc.mu  ~ dgamma(0.1,0.1)
  tau_proc.mup ~ dgamma(0.1,0.1)
  tau_h.mu ~ dgamma(0.1,0.1)
  tau_obs  ~ dgamma(0.1,0.1)

  ## Process model: Landscape scale
  mu[1] <- mu0
  for(y in 2:ny){
    E[y] <- log(mu[y-1]) 
    mu[y] ~ dlnorm(E[y],tau_proc.mu)
  }

  ## Process model: Site scale
##  pmp <- tau_proc.mup+tau_h.mu
  pmp <- tau_proc.mup               ## simplified that drop's hier
  for(s in 1:ns){
##    Emp[s,1] <- log(mup0[s])*tau_proc.mup/pmp + log(mu[1])*tau_h.mu/pmp
#    Emp[s,1] <- log(mup0[s])
#    mup[s,1] ~ dlnorm(Emp[s,1],pmp)
    mup[s,1] <- mup0[s]
    for(y in 2:ny){
##      Emp[s,y] <- log(mup[s,y-1])*tau_proc.mup/pmp + log(mu[y])*tau_h.mu/pmp
      Emp[s,y] <- log(mup[s,y-1])
      mup[s,y] ~ dlnorm(Emp[s,y],pmp)
      }
  }

  ## observation model
  for(i in 1:n){
    theta[i] <- mup[si[i],yi[i]]
    Emass[i] ~ dnorm(theta[i],tau_obs)
  }

  ## Stem Density ################
  rho0 ~ dlnorm(-2,0.001)
  for(i in 1:ns){
    rhop0[i] ~ dlnorm(-2,0.001)
  }
  tau_proc.rho ~ dgamma(0.1,0.1)  # process landscale     ### ending up too tight
  tau_proc.rhop ~ dgamma(5,0.0005) # process within site              ### HACK
  tau_h.rho ~ dgamma(0.1,0.1)     # heterogeneity among sites

  ## State space latent rho
  rho[1] <- rho0
  for(y in 2:ny){
    Er[y] <- log(rho[y-1]) 
    rho[y] ~ dlnorm(Er[y],tau_proc.rho)
  }
## seems to be missing any rhop

## need some way to represent
## rhop[s,y] ~ dlnorm(log(rho[y]),tau_h.rho)
## rhop[s,y] ~ dlnorm(log(rhop[s,y]),tau_proc.rhop)

  ## state space latent rhop
  prp <- tau_proc.rhop+tau_h.rho
  for(s in 1:ns){
    Erp[s,1] <- log(rhop0[s])*tau_proc.rhop/prp + log(rho[1])*tau_h.rho/prp
    rhop[s,1] ~ dlnorm(Erp[s,1],prp)
    for(y in 2:ny){
      Erp[s,y] <- log(rhop[s,y-1])*tau_proc.rhop/prp + log(rho[y])*tau_h.rho/prp #E[rhop];  INELEGANT SOL'N
      rhop[s,y] ~ dlnorm(Erp[s,y],prp)
      }
  }

## should the effect of rho on rhop be a MA? A site random effect? An AR1? 
## Expect anomalies to persist  *******

  ## observation model
  for(i in 1:nobs){
    Ecount[i] <- rhop[census.time[i,1],census.year[census.time[i,2]]]*census.area[census.time[i,1],census.time[i,2]]
##    Ecount[i] <- rho[census.year[census.time[i,2]]]*census.area[census.time[i,1],census.time[i,2]]
    stem.count[census.time[i,1],census.time[i,2]] ~ dpois(Ecount[i])
  }

}
"

## compile JAGS model
j.model   <- jags.model (file = textConnection(BasicBudget),
                           data = data,
                           inits = init,
                           n.chains = 3)

```


```{r}
## burn-in
bmcmc   <- coda.samples(model = j.model,
                              variable.names = c("mu","mup","tau_obs","tau_proc.mu","tau_proc.mup","rho","tau_proc.rho","tau_h.rho","tau_proc.rhop","rhop"),
                              n.iter = 3000)

```


## 7. Post-Processing & Convergence Checking

```{r}
plot(bmcmc)  		## mcmc history and density plot
autocorr.plot(bmcmc)		## autocorrelation
cumuplot(bmcmc)		## quantile plot
gelman.plot(bmcmc)		## GRB statistic
summary(bmcmc)		## summary table
mu = as.data.frame(as.matrix(bmcmc))$mu
quantile(mu,c(0.025,0.5,0.975))
```

## 8. Visualization

```{r}
b.df = as.data.frame(as.matrix(bmcmc))

cols = col2rgb(1:nsites,TRUE)
cols['alpha',]=cols['alpha',]/2
mycol <- function(i){rgb(cols[1,i],cols[2,i],cols[3,i],cols[4,i],maxColorValue=255)}

#### MEAN STEM BIOMASS ###################
ci = matrix(NA,nyears,3)
mup.ci = array(NA,c(nsites,nyears,3))
for(y in 1:nyears){
  ci[y,] <- quantile(b.df[,paste0("mu[",y,"]")],c(0.025,0.5,0.975))
  for(s in 1:nsites){
    mup.ci[s,y,] = quantile(b.df[,paste0("mup[",s,",",y,"]")],c(0.025,0.5,0.975))
  }
}
#yrng=range(ci); yrng[2] = min(yrng[2],200)
yrng = c(0,1000)
plot(years,ci[,2],type='n',ylim=yrng,ylab="Mean Tree Biomass")
#ciEnvelope(years,ci[,1],ci[,3],col="lightBlue")
#lines(years,ci[,2],lwd=3)
for(s in 1:nsites){
  ciEnvelope(years,mup.ci[s,,1],mup.ci[s,,3],col=mycol(s))
}
for(s in 1:nsites){
  lines(years,mup.ci[s,,2],lty=3,col=s,lwd=2)
  points(years,site.mass[s,],col=s,lty=2,lwd=3)
}

#### MEAN STEM DENSITY ###################
ci.r = matrix(NA,nyears,3)
rhop.ci = array(NA,c(nsites,nyears,3))
for(y in 1:nyears){
  ci.r[y,] <- quantile(b.df[,paste0("rho[",y,"]")],c(0.025,0.5,0.975))
  for(s in 1:nsites){
    rhop.ci[s,y,] = quantile(b.df[,paste0("rhop[",s,",",y,"]")],c(0.025,0.5,0.975))
  }
}
plot(years,ci.r[,2],type='n',ylim=c(0,0.5)#range(ci.r)
     ,ylab="Mean Stem Density")
#ciEnvelope(years,ci.r[,1],ci.r[,3],col="lightBlue")
#lines(years,ci.r[,2],lwd=3)
for(s in 1:nsites){
  ciEnvelope(years,rhop.ci[s,,1],rhop.ci[s,,3],col=mycol(s))
}
for(s in 1:nsites){
  lines(years,rhop.ci[s,,2],lty=3,col=s,lwd=2)
  points(census.year+years[1]-1,rho[s,],col=s,lty=2,lwd=3)
}
rho2 = matrix(NA,nsites,nyears)
for(s in 1:nsites){
  rho2[s,census.year] = rho[s,]
}

### ABOVEGROUND BIOMASS ################
ci.agb = matrix(NA,nyears,3)
AGBp.ci = array(NA,c(nsites,nyears,3))
for(y in 1:nyears){
  agb = b.df[,paste0("mu[",y,"]")]*b.df[,paste0("rho[",y,"]")]*10 # kg/m2 -> Mg/ha
  ci.agb[y,] <- quantile(agb,c(0.025,0.5,0.975))
  for(s in 1:nsites){
    AGBp.ci[s,y,] = quantile(b.df[,paste0("rhop[",s,",",y,"]")]*b.df[,paste0("mup[",s,",",y,"]")],c(0.025,0.5,0.975))*10
  }
}
agb.raw = rho2*site.mass*10
yrng=c(0,500)#range(AGBp.median)#range(ci); yrng[2] = min(yrng[2],150)
plot(years,ci.agb[,2],type='n',ylim=yrng,ylab="Mean AGB (Mg/ha)")
#ciEnvelope(years,ci.agb[,1],ci.agb[,3],col="lightBlue")
#lines(years,ci.agb[,2],lwd=3)
for(s in 1:nsites){
  ciEnvelope(years,AGBp.ci[s,,1],AGBp.ci[s,,3],col=mycol(s))
}
for(s in 1:nsites){
  lines(years,AGBp.ci[s,,2],lty=3,col=s,lwd=2)
  points(years,agb.raw[s,],col=s,lty=2,lwd=3)
}

## Composite AGB



## Plot the bivariate evolution of mean tree size and density
ylim=range(rhop.ci[,,2])
xlim=range(mup.ci[,,2])
yr=years-years[1]+1
plot(mup.ci[1,,2],rhop.ci[1,,2],type='n',xlim=xlim,ylim=ylim,
    ylab="Stem Density",xlab="Mean Tree Biomass")
for(i in 1:nsites){
  arrows(mup.ci[i,-nyears,2],rhop.ci[i,-nyears,2],mup.ci[i,-1,2],rhop.ci[i,-1,2],col=i,length=0.1)
#  points(rho2[i,],site.mass[i,],col=i)
}


```

