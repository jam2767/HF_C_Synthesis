---
title: "Basic Budget"
author: "Mike Dietze"
date: "December 9, 2014"
output: html_document
---

## TASKS

1. Load up data
2. Estimate any uncertainties required as inputs, but which were not provided in the data
3. Format data for JAGS
4. Specify / Estimate Priors
5. Specify / Estimate Initial Conditions for MCMC
6. Basic Code
7. Post-Processing & Convergence Checking
8. Visualization

## 0. Settings, etc

```{r}
setwd("~/Dropbox/HF C Synthesis")
library(rjags)

ciEnvelope <- function(x,ylo,yhi,...){
  polygon(cbind(c(x, rev(x), x[1]), c(ylo, rev(yhi),
                                      ylo[1])), border = NA,...) 
}
```


## 1. Load up data

```{r}
tree = read.csv("Data/live trees/hf-c-trees-live.csv",header=TRUE)
tree = tree[,-grep('^X',colnames(tree))]  ## drop columns with names starting with X
tree = tree[-which(is.na(tree$dbh)),] ## drop rows with missing DBH
tree = tree[-which(tree$obs.exp == "exp"),] ## drop trees from experimental manipulations

## Testing subset
tree = tree[which(tree$site %in% c("ems","hemlock","red pine plantation","mixed hardwood","pisgah")),]
```


## 2. Estimate any uncertainties required as inputs, but which were not provided in the data

### 2a. Load Allometric posteriors
```{r}
b0 = -2.48
b1 = 2.48
B = c(b0,b1)
SIGMA = solve(diag(0.01,2))
tau.allom = 1000
```


## 3. Format data for JAGS

```{r}

year = tree$year
years = min(year):max(year)
nyears = length(years)
year.index = year+1-years[1]

site = as.factor(as.character(tree$site))
sites = unique(site)
nsites = length(sites)
site.index = as.integer(site)

plot = as.factor(paste0(as.character(site),"+",as.character(tree$plot)))
plots = unique(plot)
nplots = length(plots)
plot.index = as.integer(plot)

s2p = table(site,plot)

area = tree$size
plot.area = tapply(area,plot,mean,na.rm=TRUE)
plot.yr.cnt = table(plot,year)
stem.count = apply(plot.yr.cnt,2,sum,na.rm=TRUE)
plot.yr.area = plot.yr.cnt
for(y in 1:ncol(plot.yr.area)){
  sel = which(plot.yr.area[,y]>0)
  plot.yr.area[sel,y] = plot.area[sel]
}
census.area = apply(plot.yr.area,2,sum,na.rm=TRUE)
census.year = as.numeric(names(census.area))-years[1]+1

## need to break out census.area & census.time by SITE
site.yr.cnt = site.yr.area = matrix(NA,nrow(s2p),ncol(plot.yr.area))
mch = match(colnames(s2p),rownames(plot.yr.area))
s2pv = apply(s2p,2,function(s){which(as.logical(s))})
for(y in 1:ncol(plot.yr.area)){
  site.yr.area[,y] = tapply(plot.yr.area[,y],s2pv,sum)
  site.yr.cnt[,y]  = tapply(plot.yr.cnt[,y],s2pv,sum)
}
#site.yr.area[is.na(site.yr.cnt)] <- NA
#site.yr.cnt[is.na(site.yr.cnt)] <- NA
site.yr.time = which(site.yr.cnt > 0,arr.ind = TRUE)

rho = site.yr.cnt/site.yr.area;rho[is.nan(rho)] <- NA
plot(rho[1,],ylim=range(rho,na.rm=TRUE),type='l')
for(s in 2:nsites){
  lines(rho[s,])
}

#data = list(dbh=tree$dbh,n=nrow(tree),ny=nyears,yi=year.index,stem.count=stem.count,census.area=census.area,census.time=census.time,B=B,SIGMA=SIGMA,tau.allom=tau.allom)

data = list(dbh=tree$dbh,n=nrow(tree),ny=nyears,yi=year.index,stem.count=site.yr.cnt,census.area=site.yr.area,census.time=site.yr.time,B=B,SIGMA=SIGMA,tau.allom=tau.allom,ns=nsites,nobs=nrow(site.yr.time),census.year=census.year)



```


## 4. Specify / Estimate Priors


## 5. Specify / Estimate Initial Conditions for MCMC
```{r}
x = tree$dbh
mu.ic = mean(x,na.rm=TRUE)
prec.ic = 1/var(x,na.rm=TRUE)
alpha.ic = mu.ic - tapply(x,year.index,mean,na.rm=TRUE)
tau_year.ic = 1/var(alpha.ic,na.rm=TRUE)
alpha.ic[as.numeric(names(alpha.ic))] <- alpha.ic
alpha.ic[is.na(alpha.ic)] <- rnorm(sum(is.na(alpha.ic)),0,sqrt(1/tau_year.ic))

rhop.ic = apply(rho,1,mean,na.rm=TRUE)
tau_h.ic = 1/var(rhop.ic)
rho.ic = mean(rhop.ic)
tau_proc.rhop.ic = 1/mean(apply(rho,1,function(x){var(diff(x),na.rm=TRUE)}),na.rm=TRUE)

init =  list(mu=mu.ic+alpha.ic,tau_obs=prec.ic,tau_proc=tau_year.ic,rhop0=rhop.ic,rho0=rho.ic,tau_proc.rhop=tau_proc.rhop.ic,tau_h.rho=tau_h.ic)
```

## 6. Basic Code

```{r}
BasicBudget = "
data{
  b ~ dmnorm(B,SIGMA)
  for(i in 1:n){
    mu.allom[i] <- b[1] + b[2]*log(dbh[i]) ## expected allometric biomass, log scale
    Emass[i] ~ dlnorm(mu.allom[i],tau.allom) 
  }
}
model{

  ## Stem Biomass
  mu0 ~ dnorm(20,0.001)
  tau_proc ~ dgamma(0.1,0.1)
  tau_obs ~ dgamma(0.1,0.1)

  ## Process model
  mu[1] <- mu0
  for(y in 2:ny){
    E[y] <- log(mu[y-1]) 
    mu[y] ~ dlnorm(E[y],tau_proc)
  }

  ## observation model
  for(i in 1:n){
    theta[i] <- log(mu[yi[i]])
    Emass[i] ~ dlnorm(theta[i],tau_obs)
  }

  ## Stem Density ################
  rho0 ~ dlnorm(-2,0.001)
  for(i in 1:ns){
    rhop0[i] ~ dlnorm(-2,0.001)
#    rhop[i,1] <- rhop0[i]
  }
  tau_proc.rho ~ dgamma(0.1,0.1)  # process landscale     ### ending up too tight
  tau_proc.rhop ~ dgamma(5,0.0005) # process within site              ### HACK
  tau_h.rho ~ dgamma(0.1,0.1)     # heterogeneity among sites
#  tau_obs.rho ~ dgamma(0.1,0.1)   

  ## State space latent rho
  rho[1] <- rho0
  for(y in 2:ny){
    Er[y] <- log(rho[y-1]) 
    rho[y] ~ dlnorm(Er[y],tau_proc.rho)
  }
## seems to be missing any rhop

## need some way to represent
## rhop[s,y] ~ dlnorm(log(rho[y]),tau_h.rho)
## rhop[s,y] ~ dlnorm(log(rhop[s,y]),tau_proc.rhop)

  ## state space latent rhop
  prp <- tau_proc.rhop+tau_h.rho
  for(s in 1:ns){
    Erp[s,1] <- log(rhop0[s])*tau_proc.rhop/prp + log(rho[1])*tau_h.rho/prp
    rhop[s,1] ~ dlnorm(Erp[s,1],prp)
    for(y in 2:ny){
      Erp[s,y] <- log(rhop[s,y-1])*tau_proc.rhop/prp + log(rho[y])*tau_h.rho/prp #E[rhop];  INELEGANT SOL'N
      rhop[s,y] ~ dlnorm(Erp[s,y],prp)
      }
  }

## should the effect of rho on rhop be a MA? A site random effect? An AR1? 
## Expect anomalies to persist  *******

  ## observation model
  for(i in 1:nobs){
    Ecount[i] <- rhop[census.time[i,1],census.year[census.time[i,2]]]*census.area[census.time[i,1],census.time[i,2]]
##    Ecount[i] <- rho[census.year[census.time[i,2]]]*census.area[census.time[i,1],census.time[i,2]]
    stem.count[census.time[i,1],census.time[i,2]] ~ dpois(Ecount[i])
  }

}
"

## compile JAGS model
j.model   <- jags.model (file = textConnection(BasicBudget),
                           data = data,
                           inits = init,
                           n.chains = 3)

```


```{r}
## burn-in
bmcmc   <- coda.samples (model = j.model,
                              variable.names = c("mu","tau_obs","tau_proc","rho","tau_proc.rho","tau_h.rho","tau_proc.rhop","rhop"),
                              n.iter = 3000)

```


## 7. Post-Processing & Convergence Checking

```{r}
plot(bmcmc)  		## mcmc history and density plot
autocorr.plot(bmcmc)		## autocorrelation
cumuplot(bmcmc)		## quantile plot
gelman.plot(bmcmc)		## GRB statistic
summary(bmcmc)		## summary table
mu = as.data.frame(as.matrix(bmcmc))$mu
quantile(mu,c(0.025,0.5,0.975))
```

## 8. Visualization

```{r}
b.df = as.data.frame(as.matrix(bmcmc))

ci = matrix(NA,nyears,3)
for(y in 1:nyears){
  ci[y,] <- quantile(b.df[,paste0("mu[",y,"]")],c(0.025,0.5,0.975))
}
yrng=range(ci); yrng[2] = min(yrng[2],200)
plot(years,ci[,2],type='n',ylim=yrng,ylab="Mean Tree Biomass")
ciEnvelope(years,ci[,1],ci[,3],col="lightBlue")
lines(years,ci[,2],lwd=3)

ci.r = matrix(NA,nyears,3)
rhop.median = matrix(NA,nsites,nyears)
for(y in 1:nyears){
  ci.r[y,] <- quantile(b.df[,paste0("rho[",y,"]")],c(0.025,0.5,0.975))
  for(s in 1:nsites){
    rhop.median[s,y] = median(b.df[,paste0("rhop[",s,",",y,"]")])
  }
}
plot(years,ci.r[,2],type='n',ylim=c(0,0.5)#range(ci.r)
     ,ylab="Mean Stem Density")
ciEnvelope(years,ci.r[,1],ci.r[,3],col="lightBlue")
lines(years,ci.r[,2],lwd=3)
for(s in 1:nsites){
  lines(years,rhop.median[s,],lty=3,col=s,lwd=2)
}
for(s in 1:nsites){
  points(census.year+years[1]-1,rho[s,],col=s,lty=2,lwd=3)
}

ci.agb = matrix(NA,nyears,3)
for(y in 1:nyears){
  agb = b.df[,paste0("mu[",y,"]")]*b.df[,paste0("rho[",y,"]")]*10 # kg/m2 -> Mg/ha
  ci.agb[y,] <- quantile(agb,c(0.025,0.5,0.975))
}
yrng=range(ci); yrng[2] = min(yrng[2],150)
plot(years,ci.agb[,2],type='n',ylim=yrng,ylab="Mean AGB (Mg/ha)")
ciEnvelope(years,ci.agb[,1],ci.agb[,3],col="lightBlue")
lines(years,ci.agb[,2],lwd=3)


## Plot the evolution of mean tree size and density



```

